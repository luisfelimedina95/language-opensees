'.dyn.caret.begin.document':
  '#!/usr/bin/env tcl':
    'prefix': 'tcl'
    'body': '#!/usr/bin/env tcl\n'
'.source.opensees':

# ============================================================================ #
#                          OPENSEES SPECIFIC SNIPPETS                          #
# ============================================================================ #

# MODELLING COMMANDS
# General
  'model...':
    'prefix': 'model'
    'body': 'model BasicBuilder -ndm $ndm <-ndf $ndf>'
  'node...':
    'prefix': 'node'
    'body': 'node $nodeTag (ndm $coords) <-mass (ndf $massValues)>'
  'mass...':
    'prefix': 'mass'
    'body': 'mass $nodeTag (ndf $massValues)'
  'region...':
    'prefix': 'region'
    'body': 'region $regTag <-ele ($ele1 $ele2 ...)> <-eleRange $startEle $endEle> <-node ($node1 $node2 ...)> <-nodeRange $startNode $endNode> <-node all> <-rayleigh $alphaM $betaK $betaKinit $betaKcomm>'
  'rayleigh...':
    'prefix': 'rayleigh'
    'body': 'rayleigh $alphaM $betaK $betaKinit $betaKcomm'
# Uniaxial materials
  'uniaxialMaterial Steel01...':
    'prefix': 'uniaxialMaterial Steel01'
    'body': 'uniaxialMaterial Steel01 $matTag $Fy $E0 $b <$a1 $a2 $a3 $a4>'
  'uniaxialMaterial Hysteretic...':
    'prefix': 'uniaxialMaterial Hysteretic'
    'body': 'uniaxialMaterial Hysteretic $matTag $s1p $e1p $s2p $e2p <$s3p $e3p> $s1n $e1n $s2n $e2n <$s3n $e3n> $pinchX $pinchY $damage1 $damage2 <$beta>'
  'uniaxialMaterial Concrete01...':
    'prefix': 'uniaxialMaterial Concrete01'
    'body': 'uniaxialMaterial Concrete01 $matTag $fpc $epsc0 $fpcu $epsU'
  'uniaxialMaterial Elastic...':
    'prefix': 'uniaxialMaterial Elastic'
    'body': 'uniaxialMaterial Elastic $matTag $E <$eta> <$Eneg>'
  'uniaxialMaterial ElasticPP...':
    'prefix': 'uniaxialMaterial ElasticPP'
    'body': 'uniaxialMaterial ElasticPP $matTag $E $epsyP <$epsyN $eps0>'
  'uniaxialMaterial ElasticPPGap...':
    'prefix': 'uniaxialMaterial ElasticPPGap'
    'body': 'uniaxialMaterial ElasticPPGap $matTag $E $Fy $gap <$eta> <damage>'
  'uniaxialMaterial ENT...':
    'prefix': 'uniaxialMaterial ENT'
    'body': 'uniaxialMaterial ENT $matTag $E'
  'uniaxialMaterial Parallel...':
    'prefix': 'uniaxialMaterial Parallel'
    'body': 'uniaxialMaterial Parallel $matTag $tag1 $tag2 ... <-factors $fact1 $fact2 ...>'
  'uniaxialMaterial Series...':
    'prefix': 'uniaxialMaterial Series'
    'body': 'uniaxialMaterial Series $matTag $tag1 $tag2 ...'
# Elements
  'element zeroLength...':
    'prefix': 'element zeroLength'
    'body': 'element zeroLength $eleTag $iNode $jNode -mat $matTag1 $matTag2 ... -dir $dir1 $dir2 ...<-doRayleigh $rFlag> <-orient $x1 $x2 $x3 $yp1 $yp2 $yp3>'
  'element truss...':
    'prefix': 'element truss'
    'body': 'element truss $eleTag $iNode $jNode $A $matTag <-rho $rho> <-cMass $cFlag> <-doRayleigh $rFlag>'
  'element elasticBeamColumn (2D)...':
    'prefix': 'element elasticBeamColumn (2D)'
    'body': 'element elasticBeamColumn $eleTag $iNode $jNode $A $E $Iz $transfTag <-mass $massDens> <-cMass>'
  'element elasticBeamColumn (3D)...':
    'prefix': 'element elasticBeamColumn (3D)'
    'body': 'element elasticBeamColumn $eleTag $iNode $jNode $A $E $G $J $Iy $Iz $transfTag <-mass $massDens> <-cMass>'
# Geometric Transformations
  'geomTransf Linear (2D)...':
    'prefix': 'geomTransf Linear (2D)'
    'body': 'geomTransf Linear $transfTag <-jntOffset $dXi $dYi $dXj $dYj>'
  'geomTransf Linear (3D)...':
    'prefix': 'geomTransf Linear (3D)'
    'body': 'geomTransf Linear $transfTag $vecxzX $vecxzY $vecxzZ <-jntOffset $dXi $dYi $dZi $dXj $dYj $dZj>'
  'geomTransf PDelta (2D)...':
    'prefix': 'geomTransf PDelta (2D)'
    'body': 'geomTransf PDelta $transfTag <-jntOffset $dXi $dYi $dXj $dYj>'
  'geomTransf PDelta (3D)...':
    'prefix': 'geomTransf PDelta (3D)'
    'body': 'geomTransf PDelta $transfTag $vecxzX $vecxzY $vecxzZ <-jntOffset $dXi $dYi $dZi $dXj $dYj $dZj>'
  'geomTransf Corotational (2D)...':
    'prefix': 'geomTransf Corotational (2D)'
    'body': 'geomTransf Corotational $transfTag <-jntOffset $dXi $dYi $dXj $dYj>'
  'geomTransf Corotational (3D)...':
    'prefix': 'geomTransf Corotational (3D)'
    'body': 'geomTransf Corotational $transfTag $vecxzX $vecxzY $vecxzZ'
# Sections






  'section Fiber...':
    'prefix': 'section Fiber'
    'body': 'section Fiber $secTag <-GJ $GJ> {\n\tfiber...\n\tpatch...\n\tlayer...\n\t...\n}'
  'section NDFiber...':
    'prefix': 'section NDFiber'
    'body': 'section NDFiber $secTag {\n\tfiber...\n\tpatch...\n\tlayer...\n\t...\n}'
  'section RCSection2d...':
    'prefix': 'section RCSection2d'
    'body': 'section RCSection2d $secTag $coreTag $coverTag $steelTag $d $b $cover $Atop $Abot $Aside $Nfcore $Nfcover $Nfs'
  'fiber...':
    'prefix': 'fiber'
    'body': 'fiber $yLoc $zLoc $A $matTag'
  'patch quad...':
    'prefix': 'patch quad'
    'body': 'patch quad $matTag $numSubdivIJ $numSubdivJK $yI $zI $yJ $zJ $yK $zK $yL $zL'
  'patch rect...':
    'prefix': 'patch rect'
    'body': 'patch rect $matTag $numSubdivY $numSubdivZ $yI $zI $yJ $zJ'
  'patch circ...':
    'prefix': 'patch circ'
    'body': 'patch circ $matTag $numSubdivCirc $numSubdivRad $yCenter $zCenter $intRad $extRad $startAng $endAng'
  'layer straight...':
    'prefix': 'layer straight'
    'body': 'layer straight $matTag $numFiber $areaFiber $yStart $zStart $yEnd $zEnd'
  'layer circ...':
    'prefix': 'layer circ'
    'body': 'layer circ $matTag $numFiber $areaFiber $yCenter $zCenter $radius <$startAng $endAng>'
# SP Constraints
  'fix...':
    'prefix': 'fix'
    'body': 'fix $nodeTag (ndf $constrValues)'
  'fixX...':
    'prefix': 'fixX'
    'body': 'fixX $xCoordinate (ndf $ConstrValues) <-tol $tol>'
  'fixY...':
    'prefix': 'fixY'
    'body': 'fixY $yCoordinate (ndf $ConstrValues) <-tol $tol>'
  'fixZ...':
    'prefix': 'fixZ'
    'body': 'fixZ $zCoordinate (ndf $ConstrValues) <-tol $tol>'
# MP Constraints
  'equalDOF...':
    'prefix': 'equalDOF'
    'body': 'equalDOF $rNodeTag $cNodeTag $dof1 $dof2 ...'
  'rigidDiaphragm...':
    'prefix': 'rigidDiaphragm'
    'body': 'rigidDiaphragm $perpDirn $masterNodeTag $slaveNodeTag1 $slaveNodeTag2 ...'
  'rigidLink...':
    'prefix': 'rigidLink'
    'body': 'rigidLink $type $masterNodeTag $slaveNodeTag'
# TimeSeries
  'timeSeries Constant...':
    'prefix': 'timeSeries Constant'
    'body': 'timeSeries Constant $tag <-factor $cFactor>'
  'timeSeries Linear...':
    'prefix': 'timeSeries Linear'
    'body': 'timeSeries Linear $tag <-factor $cFactor>'
  'timeSeries Trig...':
    'prefix': 'timeSeries Trig'
    'body': 'timeSeries Trig $tag $tStart $tEnd $period <-factor $cFactor> <-shift $shift>'
  'timeSeries Triangle...':
    'prefix': 'timeSeries Triangle'
    'body': 'timeSeries Triangle $tag $tStart $tEnd $period <-shift $shift> <-factor $cFactor>'
  'timeSeries Rectangular...':
    'prefix': 'timeSeries Rectangular'
    'body': 'timeSeries Rectangular $tag $tStart $tEnd <-factor $cFactor>'
  'timeSeries Pulse...':
    'prefix': 'timeSeries Pulse'
    'body': 'timeSeries Pulse $tag $tStart $tEnd $period <-width $pulseWidth> <-shift $shift> <-factor $cFactor>'
  'timeSeries Path (tcl list, const dt)...':
    'prefix': 'timeSeries Path (tcl list, const dt)'
    'body': 'timeSeries Path $tag -dt $dt -values {list_of_values} <-factor $cFactor> <-useLast> <-prependZero> <-startTime $tStart>'
  'timeSeries Path (file, const dt)...':
    'prefix': 'timeSeries Path (file, const dt)'
    'body': 'timeSeries Path $tag -dt $dt -filePath $filePath <-factor $cFactor> <-useLast> <-prependZero> <-startTime $tStart>'
  'timeSeries Path (tcl list, var dt)...':
    'prefix': 'timeSeries Path (tcl list, var dt)'
    'body': 'timeSeries Path $tag -time {list_of_times} -values {list_of_values} <-factor $cFactor> <-useLast>'
  'timeSeries Path (file, var dt)...':
    'prefix': 'timeSeries Path (file, var dt)'
    'body': 'timeSeries Path $tag -fileTime $fileTime -filePath $filePath <-factor $cFactor> <-useLast>'
  'timeSeries PeerMotion...':
    'prefix': 'timeSeries PeerMotion'
    'body': 'timeSeries PeerMotion $tag $eqMotion $station $type $factor <-dT $dT> <-nPTS $nPts>'
  'timeSeries PeerNGAMotion...':
    'prefix': 'timeSeries PeerNGAMotion'
    'body': 'timeSeries PeerNGAMotion $tag $eqMotion $factor <-dT $dT> <-NPTS $nPts>'
# Patterns
  'pattern Plain...':
    'prefix': 'pattern Plain'
    'body': 'pattern Plain $patternTag $tsTag <-fact $cFactor> {\n\tload...\n\teleLoad...\n\tsp...\n\t...\n}'
  'pattern UniformExcitation...':
    'prefix': 'pattern UniformExcitation'
    'body': 'pattern UniformExcitation $patternTag $dir -accel $tsTag <-vel0 $vel0> <-fact $cFactor>'
  'pattern MultipleSupport...':
    'prefix': 'pattern MultipleSupport'
    'body': 'pattern MultipleSupport $patternTag {\n\tgroundMotion...\n\timposedMotion...\n\t...\n}'
  'load...':
    'prefix': 'load'
    'body': 'load $nodeTag (ndf $LoadValues)'
  'eleLoad -ele (2D)...':
    'prefix': 'eleLoad -ele (2D)'
    'body': 'eleLoad -ele $eleTag1 <$eleTag2 ....> -type -beamUniform $Wy <$Wx>'
  'eleLoad -range (2D)...':
    'prefix': 'eleLoad -range (2D)'
    'body': 'eleLoad -range $eleTag1 $eleTag2 -type -beamPoint $Py $xL <$Px>'
  'eleLoad -ele (3D)...':
    'prefix': 'eleLoad -ele (3D)'
    'body': 'eleLoad -ele $eleTag1 <$eleTag2 ....> -type -beamUniform $Wy $Wz <$Wx>'
  'eleLoad -range (3D)...':
    'prefix': 'eleLoad -range (3D)'
    'body': 'eleLoad -range $eleTag1 $eleTag2 -type -beamPoint $Py $Pz $xL <$Px>'
  'sp...':
    'prefix': 'sp'
    'body': 'sp $nodeTag $dofTag $dofValue'
  'groundMotion Plain...':
    'prefix': 'groundMotion Plain'
    'body': 'groundMotion $gmTag Plain <-accel $tsTag> <-vel $tsTag> <-disp $tsTag> <-int (IntegratorType intArgs)> <-fact $cFactor>'
  'groundMotion Interpolated...':
    'prefix': 'groundMotion Interpolated'
    'body': 'groundMotion $tag Interpolated $gmTag1 $gmTag2 ... -fact $fact1 $fact2 ...'
  'imposedMotion $nodeTag...':
    'prefix': 'imposedMotion $nodeTag'
    'body': 'imposedMotion $nodeTag $dirn $gMotionTag'

# OUTPUT COMMANDS
# Recorders
  'recorder Node...':
    'prefix': 'recorder Node'
    'body': 'recorder Node <-file $fileName> <-xml $fileName> <-binary $fileName> <-tcp $inetAddress $port> <-precision $nSD> <-timeSeries $tsTag> <-time> <-dT $deltaT> <-closeOnWrite> <-node $node1 $node2 ...> <-nodeRange $startNode $endNode> <-region $regionTag> -dof ($dof1 $dof2 ...) $respType'
  'recorder EnvelopeNode...':
    'prefix': 'recorder EnvelopeNode'
    'body': 'recorder EnvelopeNode <-file $fileName> <-xml $fileName> <-precision $nSD> <-time> <-closeOnWrite> <-timeSeries $tsTag> <-node $node1 $node2 ...> <-nodeRange $startNode $endNode> <-region $regionTag> -dof ($dof1 $dof2 ...) $respType'
  'recorder Drift...':
    'prefix': 'recorder Drift'
    'body': 'recorder Drift <-file $fileName> <-xml $fileName> <-binary $fileName> <-tcp $inetAddress $port> <-precision $nSD> <-time> -iNode $inode1 $inode2 ... -jNode $jnode1 $jnode2 ... -dof $dof1 $dof2 ... -perpDirn $perpDirn1 $perpDirn2 ...'
  'recorder Element...':
    'prefix': 'recorder Element'
    'body': 'recorder Element <-file $fileName> <-xml $fileName> <-binary $fileName> <-precision $nSD> <-time> <-closeOnWrite> <-dT $deltaT> <-ele ($ele1 $ele2 ...)> <-eleRange $startEle $endEle> <-region $regTag> $arg1 $arg2 ...'
  'recorder EnvelopeElement...':
    'prefix': 'recorder EnvelopeElement'
    'body': 'recorder EnvelopeElement <-file $fileName> <-xml $fileName> <-binary $fileName> <-precision $nSD> <-time> <-closeOnWrite> <-ele ($ele1 $ele2 ...)> <-eleRange $startEle $endEle> <-region $regTag> $arg1 $arg2 ...'
  'recorder plot...':
    'prefix': 'recorder plot'
    'body': 'recorder plot $fileName $windowTitle $xLoc $yLoc $xPixels $yPixels -columns $xCol0 $yCol0 <-columns $xCol1 $yCol1> ...'
  'record...':
    'prefix': 'record'
    'body': 'record'
# Print
  'print...':
    'prefix': 'print'
    'body': 'print <$fileName>'
  'print -node...':
    'prefix': 'print -node'
    'body': 'print <$fileName> -node <-flag $flag> <$node1 $node2 ...>'
  'print -ele...':
    'prefix': 'print -ele'
    'body': 'print <$fileName> -ele <-flag $flag> <$ele1 $ele2 ...>'
  'printA...':
    'prefix': 'printA'
    'body': 'printA <-file $fileName>'
  'logFile...':
    'prefix': 'logFile'
    'body': 'logFile $fileName <-append>'
# RealTime Outputs
  'eleResponse...':
    'prefix': 'eleResponse'
    'body': 'eleResponse $eleTag $arg1 $arg2'
  'nodeDisp...':
    'prefix': 'nodeDisp'
    'body': 'nodeDisp $nodeTag <$dof>'
  'nodeVel...':
    'prefix': 'nodeVel'
    'body': 'nodeVel $nodeTag <$dof>'
  'nodeAccel...':
    'prefix': 'nodeAccel'
    'body': 'nodeAccel $nodeTag <$dof>'
  'nodeEigenvector...':
    'prefix': 'nodeEigenvector'
    'body': 'nodeEigenvector $nodeTag $eigenvector <$dof>'
  'getTime...':
    'prefix': 'getTime'
    'body': 'getTime'

# MISC COMMANDS
  'exit...':
    'prefix': 'exit'
    'body': 'exit'
  'loadConst...':
    'prefix': 'loadConst'
    'body': 'loadConst <-time $pseudoTime>'
  'remove element...':
    'prefix': 'remove element'
    'body': 'remove element $eleTag'
  'remove node...':
    'prefix': 'remove node'
    'body': 'remove node $nodeTag'
  'remove loadPattern...':
    'prefix': 'remove loadPattern'
    'body': 'remove loadPattern $patternTag'
  'remove parameter...':
    'prefix': 'remove parameter'
    'body': 'remove parameter $paramTag'
  'remove recorders...':
    'prefix': 'remove recorders'
    'body': 'remove recorders'
  'remove recorder...':
    'prefix': 'remove recorder'
    'body': 'remove recorder $tag'
  'remove sp...':
    'prefix': 'remove sp'
    'body': 'remove sp $nodeTag $dof'
  'remove mp...':
    'prefix': 'remove mp'
    'body': 'remove mp $constrainedNodeTag'
  'reset...':
    'prefix': 'reset'
    'body': 'reset'
  'setMaxOpenFiles...':
    'prefix': 'setMaxOpenFiles'
    'body': 'setMaxOpenFiles $maxNumFiles'
  'setTime...':
    'prefix': 'setTime'
    'body': 'setTime $pseudoTime'
  'testIter...':
    'prefix': 'testIter'
    'body': 'testIter'
  'testNorms...':
    'prefix': 'testNorms'
    'body': 'testNorms'
  'wipe...':
    'prefix': 'wipe'
    'body': 'wipe'
  'wipeAnalysis...':
    'prefix': 'wipeAnalysis'
    'body': 'wipeAnalysis'

# ANALYSIS COMMANDS
# Constraints
  'constraints Plain...':
    'prefix': 'constraints Plain'
    'body': 'constraints Plain'
  'constraints Lagrange...':
    'prefix': 'constraints Lagrange'
    'body': 'constraints Lagrange <$alphaS $alphaM>'
  'constraints Penalty...':
    'prefix': 'constraints Penalty'
    'body': 'constraints Penalty $alphaS $alphaM'
  'constraints Transformation...':
    'prefix': 'constraints Transformation'
    'body': 'constraints Transformation'
# Numberers
  'numberer Plain...':
    'prefix': 'numberer Plain'
    'body': 'numberer Plain'
  'numberer RCM...':
    'prefix': 'numberer RCM'
    'body': 'numberer RCM'
  'numberer AMD...':
    'prefix': 'numberer AMD'
    'body': 'numberer AMD'
# Systems
  'system BandGeneral...':
    'prefix': 'system BandGeneral'
    'body': 'system BandGeneral'
  'system BandSPD...':
    'prefix': 'system BandSPD'
    'body': 'system BandSPD'
  'system ProfileSPD...':
    'prefix': 'system ProfileSPD'
    'body': 'system ProfileSPD'
  'system SuperLU...':
    'prefix': 'system SuperLU'
    'body': 'system SparseGEN'
  'system UmfPack...':
    'prefix': 'system UmfPack'
    'body': 'system UmfPack <-lvalueFact $LVALUE>'
  'system FullGeneral...':
    'prefix': 'system FullGeneral'
    'body': 'system FullGeneral'
  'system SparseSYM...':
    'prefix': 'system SparseSYM'
    'body': 'system SparseSYM'
  'system Mumps...':
    'prefix': 'system Mumps'
    'body': 'system Mumps'
  'system Cusp...':
    'prefix': 'system Cusp'
    'body': 'system CuSP -rTol $RTOL -mInt $MINT -pre $PRE -solver $SOLVER'
# Tests
  'test NormUnbalance...':
    'prefix': 'test NormUnbalance'
    'body': 'test NormUnbalance $tol $iter <$pFlag> <$nType>'
  'test NormDispIncr...':
    'prefix': 'test NormDispIncr'
    'body': 'test NormDispIncr $tol $iter <$pFlag> <$nType>'
  'test EnergyIncr...':
    'prefix': 'test EnergyIncr'
    'body': 'test EnergyIncr $tol $iter <$pFlag> <$nType>'
  'test RelativeNormUnbalance...':
    'prefix': 'test RelativeNormUnbalance'
    'body': 'test RelativeNormUnbalance $tol $iter <$pFlag> <$nType>'
  'test RelativeNormDispIncr...':
    'prefix': 'test RelativeNormDispIncr'
    'body': 'test RelativeNormDispIncr $tol $iter <$pFlag> <$nType>'
  'test RelativeTotalNormDispIncr...':
    'prefix': 'test RelativeTotalNormDispIncr'
    'body': 'test RelativeTotalNormDispIncr $tol $iter <$pFlag> <$nType>'
  'test RelativeEnergyIncr...':
    'prefix': 'test RelativeEnergyIncr'
    'body': 'test RelativeEnergyIncr $tol $iter <$pFlag> <$nType>'
  'test FixedNumIter...':
    'prefix': 'test FixedNumIter'
    'body': 'test FixedNumIter $iter <$pFlag> <$nType>'
# Algorithms
  'algorithm Linear...':
    'prefix': 'algorithm Linear'
    'body': 'algorithm Linear <-initial> <-factorOnce>'
  'algorithm Newton...':
    'prefix': 'algorithm Newton'
    'body': 'algorithm Newton <-initial> <-initialThenCurrent>'
  'algorithm NewtonLineSearch...':
    'prefix': 'algorithm NewtonLineSearch'
    'body': 'algorithm NewtonLineSearch <-type $typeSearch> <-tol $tol> <-maxIter $maxIter> <-minEta $minEta> <-maxEta $maxEta>'
  'algorithm ModifiedNewton...':
    'prefix': 'algorithm ModifiedNewton'
    'body': 'algorithm ModifiedNewton <-initial>'
  'algorithm KrylovNewton...':
    'prefix': 'algorithm KrylovNewton'
    'body': 'algorithm KrylovNewton <-iterate $tangIter> <-increment $tangIncr> <-maxDim $maxDim>'
  'algorithm SecantNewton...':
    'prefix': 'algorithm SecantNewton'
    'body': 'algorithm SecantNewton <-iterate $tangIter> <-increment $tangIncr> <-maxDim $maxDim>'
  'algorithm BFGS...':
    'prefix': 'algorithm BFGS'
    'body': 'algorithm BFGS'
  'algorithm Broyden...':
    'prefix': 'algorithm Broyden'
    'body': 'algorithm Broyden <$count>'
# Integrators
  'integrator LoadControl...':
    'prefix': 'integrator LoadControl (static)'
    'body': 'integrator LoadControl $lambda <$numIter $minLambda $maxLambda>'
  'integrator DisplacementControl...':
    'prefix': 'integrator DisplacementControl (static)'
    'body': 'integrator DisplacementControl $node $dof $incr <$numIter $ΔUmin $ΔUmax>'
  'integrator MinUnbalDispNorm...':
    'prefix': 'integrator MinUnbalDispNorm (static)'
    'body': 'integrator MinUnbalDispNorm $dlambda1 <$Jd $minLambda $maxLambda>'
  'integrator ArcLength...':
    'prefix': 'integrator ArcLength (static)'
    'body': 'integrator ArcLength $s $alpha'
  'integrator CentralDifference...':
    'prefix': 'integrator CentralDifference (transient)'
    'body': 'integrator CentralDifference'
  'integrator Newmark...':
    'prefix': 'integrator Newmark (transient)'
    'body': 'integrator Newmark $gamma $beta'
  'integrator HHT...':
    'prefix': 'integrator HHT (transient)'
    'body': 'integrator HHT $alpha <$gamma $beta>'
  'integrator GeneralizedAlpha...':
    'prefix': 'integrator GeneralizedAlpha (transient)'
    'body': 'integrator GeneralizedAlpha $alphaM $alphaF <$gamma $beta>'
  'integrator TRBDF2...':
    'prefix': 'integrator TRBDF2 (transient)'
    'body': 'integrator TRBDF2'
# Analysis
  'analysis Static...':
    'prefix': 'analysis Static'
    'body': 'analysis Static'
  'analysis Transient...':
    'prefix': 'analysis Transient'
    'body': 'analysis Transient'
  'analysis VariableTransient...':
    'prefix': 'analysis VariableTransient'
    'body': 'analysis VariableTransient'
  'eigen ...':
    'prefix': 'eigen'
    'body': 'eigen <$solver> $numEigenvalues'
  'analyze...':
    'prefix': 'analyze'
    'body': 'analyze $numIncr <$dt> <$dtMin $dtMax $Jd>'

# ============================================================================ #
#                            TCL SPECIFIC SNIPPETS                             #
# ============================================================================ #
  'for...':
    'prefix': 'for'
    'body': 'for {${1:set i 0}} {${2:\\$i < \\$n}} {${3:incr i}} {\n\t${4}\n}\n'
  'foreach...':
    'prefix': 'foreach'
    'body': 'foreach ${1:var} ${2:\\$list} {\n\t${3}\n}\n'
  'if...':
    'prefix': 'if'
    'body': 'if {${1:condition}} {\n\t${2}\n}\n'
  'proc...':
    'prefix': 'proc'
    'body': 'proc ${1:name} {${2:args}} \\\\\n{\n\t${3}\n}\n'
  'switch...':
    'prefix': 'switch'
    'body': 'switch ${1:-exact} -- ${2:\\$var} {\n\t${3:match} {\n\t\t${4}\n\t}\n\tdefault {${5}}\n}\n'
  'while...':
    'prefix': 'while'
    'body': 'while {${1:condition}} {\n\t${2}\n}\n'

# ============================================================================ #
#                       OPENSEES TEMPLATES AND EXAMPLES                        #
# ============================================================================ #
# Links
  'Link-Basic Examples Manual...':
    'prefix': 'Link - Basic Examples Manual'
    'body': 'http://opensees.berkeley.edu/wiki/index.php/Basic_Examples_Manual'
  'Link-Advanced Examples Manual...':
    'prefix': 'Link - Advanced Examples Manual'
    'body': 'http://opensees.berkeley.edu/wiki/index.php/Examples_Manual'
  'Link-Command Manual...':
    'prefix': 'Link - Command Manual'
    'body': 'http://opensees.berkeley.edu/wiki/index.php/Command_Manual'
  'Link-Discussion board...':
    'prefix': 'Link - Discussion board'
    'body': 'http://opensees.berkeley.edu/community/index.php'
# Examples
  'Example-Truss...':
    'prefix': 'Example - Truss'
    'body': '# Full documentation at:\n# http://opensees.berkeley.edu/wiki/index.php/Basic_Examples_Manual\n\n# OpenSees -- Open System for Earthquake Engineering Simulation\n# Pacific Earthquake Engineering Research Center\n# http://opensees.berkeley.edu/\n#\n# Basic Truss Example\n# ----------------------\n#  2d 3 Element Elastic Truss\n#  Single Nodal Load, Static Analysis\n#\n# Example Objectives\n# -----------------\n#  Simple Introduction to OpenSees\n#\n# Units: kips, in, sec\n# Written: fmk\n# Date: January 2001\n\n# ------------------------------\n# Start of model generation\n# ------------------------------\n\n# Remove existing model\nwipe\n\n# Create ModelBuilder (with two-dimensions and 2 DOF/node)\nmodel BasicBuilder -ndm 2 -ndf 2\n\n# Create nodes\n# ------------\n\n# Create nodes & add to Domain - command: node nodeId xCrd yCrd\nnode 1   0.0  0.0\nnode 2 144.0  0.0\nnode 3 168.0  0.0\nnode 4  72.0 96.0\n\n# Set the boundary conditions - command: fix nodeID xResrnt? yRestrnt?\nfix 1 1 1\nfix 2 1 1\nfix 3 1 1\n\n# Define materials for truss elements\n# -----------------------------------\n\n# Create Elastic material prototype - command: uniaxialMaterial Elastic matID E\nuniaxialMaterial Elastic 1 3000\n\n# Define elements\n# ---------------\n\n# Create truss elements - command: element truss trussID node1 node2 A matID\nelement Truss 1 1 4 10.0 1\nelement Truss 2 2 4  5.0 1\nelement Truss 3 3 4  5.0 1\n\n# Define loads\n# ------------\n\n#create a Linear TimeSeries (load factor varies linearly with time): command timeSeries Linear $tag\ntimeSeries Linear 1\n\n# Create a Plain load pattern with a linear TimeSeries: command pattern Plain $tag $timeSeriesTag { $loads }\npattern Plain 1 1 {\n\n    # Create the nodal load - command: load nodeID xForce yForce\n    load 4 100 -50\n}\n\n# ------------------------------\n# Start of analysis generation\n# ------------------------------\n\n# Create the system of equation, a SPD using a band storage scheme\nsystem BandSPD\n\n# Create the DOF numberer, the reverse Cuthill-McKee algorithm\nnumberer RCM\n\n# Create the constraint handler, a Plain handler is used as homo constraints\nconstraints Plain\n\n# Create the integration scheme, the LoadControl scheme using steps of 1.0\nintegrator LoadControl 1.0\n\n# Create the solution algorithm, a Linear algorithm is created\nalgorithm Linear\n\n# create the analysis object\nanalysis Static\n\n# ------------------------------\n# Start of recorder generation\n# ------------------------------\n\n# create a Recorder object for the nodal displacements at node 4\nrecorder Node -file example.out -time -node 4 -dof 1 2 disp\n\n# Create a recorder for element forces, one in global and the other local system\nrecorder Element -file eleGlobal.out -time -ele 1 2 3 forces\nrecorder Element -file eleLocal.out -time -ele 1 2 3  basicForces\n\n# ------------------------------\n# Finally perform the analysis\n# ------------------------------\n\n# Perform the analysis\nanalyze 1\n\n# ------------------------------\n# Print Stuff to Screen\n# ------------------------------\n\n# Print the current state at node 4 and at all elements\nputs "node 4 displacement: [nodeDisp 4]"\nprint node 4\nprint ele'
  'Example-MomentCurvature...':
    'prefix': 'Example - MomentCurvature'
    'body': '# Full documentation at:# Full documentation at:\n# http://opensees.berkeley.edu/wiki/index.php/Basic_Examples_Manual\n\nproc MomentCurvature {secTag axialLoad maxK {numIncr 100} } {\n	# Define two nodes at (0,0)\n	node 1 0.0 0.0\n	node 2 0.0 0.0\n\n	# Fix all degrees of freedom except axial and bending\n	fix 1 1 1 1\n	fix 2 0 1 0\n\n	# Define element\n	#                         tag ndI ndJ  secTag\n	element zeroLengthSection  1   1   2  $secTag\n\n	# Create recorder\n	recorder Node -file section$secTag.out -time -node 2 -dof 3 disp\n\n	# Define constant axial load\n	pattern Plain 1 "Constant" {\n		load 2 $axialLoad 0.0 0.0\n	}\n\n	# Define analysis parameters\n	integrator LoadControl 0.0\n	system SparseGeneral -piv;	# Overkill, but may need the pivoting!\n	test NormUnbalance 1.0e-9 10\n	numberer Plain\n	constraints Plain\n	algorithm Newton\n	analysis Static\n\n	# Do one analysis for constant axial load\n	analyze 1\n\n	# Define reference moment\n	pattern Plain 2 "Linear" {\n		load 2 0.0 0.0 1.0\n	}\n\n	# Compute curvature increment\n	set dK [expr $maxK/$numIncr]\n\n	# Use displacement control at node 2 for section analysis\n	integrator DisplacementControl 2 3 $dK 1 $dK $dK\n\n	# Do the section analysis\n	analyze $numIncr\n}\n\n\n# Define model builder\n# --------------------\nmodel basic -ndm 2 -ndf 3\n\n# Define materials for nonlinear columns\n# ------------------------------------------\n# CONCRETE                  tag   f\'c        ec0   f\'cu        ecu\n# Core concrete (confined)\nuniaxialMaterial Concrete01  1  -6.0  -0.004   -5.0     -0.014\n\n# Cover concrete (unconfined)\nuniaxialMaterial Concrete01  2  -5.0   -0.002   0.0     -0.006\n\n# STEEL\n# Reinforcing steel\nset fy 60.0;      # Yield stress\nset E 30000.0;    # Young\'s modulus\n#                        tag  fy E0    b\nuniaxialMaterial Steel01  3  $fy $E 0.01\n\n# Define cross-section for nonlinear columns\n# ------------------------------------------\n\n# set some paramaters\nset colWidth 15\nset colDepth 24\n\nset cover  1.5\nset As    0.60;     # area of no. 7 bars\n\n# some variables derived from the parameters\nset y1 [expr $colDepth/2.0]\nset z1 [expr $colWidth/2.0]\n\nsection Fiber 1 {\n\n    # Create the concrete core fibers\n    patch rect 1 10 1 [expr $cover-$y1] [expr $cover-$z1] [expr $y1-$cover] [expr $z1-$cover]\n\n    # Create the concrete cover fibers (top, bottom, left, right)\n    patch rect 2 10 1  [expr -$y1] [expr $z1-$cover] $y1 $z1\n    patch rect 2 10 1  [expr -$y1] [expr -$z1] $y1 [expr $cover-$z1]\n    patch rect 2  2 1  [expr -$y1] [expr $cover-$z1] [expr $cover-$y1] [expr $z1-$cover]\n    patch rect 2  2 1  [expr $y1-$cover] [expr $cover-$z1] $y1 [expr $z1-$cover]\n\n    # Create the reinforcing fibers (left, middle, right)\n    layer straight 3 3 $As [expr $y1-$cover] [expr $z1-$cover] [expr $y1-$cover] [expr $cover-$z1]\n    layer straight 3 2 $As 0.0 [expr $z1-$cover] 0.0 [expr $cover-$z1]\n    layer straight 3 3 $As [expr $cover-$y1] [expr $z1-$cover] [expr $cover-$y1] [expr $cover-$z1]\n\n}\n\n# Estimate yield curvature\n# (Assuming no axial load and only top and bottom steel)\nset d [expr $colDepth-$cover]	;# d -- from cover to rebar\nset epsy [expr $fy/$E]	;# steel yield strain\nset Ky [expr $epsy/(0.7*$d)]\n\n# Print estimate to standard output\nputs "Estimated yield curvature: $Ky"\n\n# Set axial load\nset P -180\n\nset mu 15;		# Target ductility for analysis\nset numIncr 100;	# Number of analysis increments\n\n# Call the section analysis procedure\nMomentCurvature 1 $P [expr $Ky*$mu] $numIncr'
  'Example-ElasticFrame...':
    'prefix': 'Example - ElasticFrame'
    'body': '# Full documentation at:\n# http://opensees.berkeley.edu/wiki/index.php/Basic_Examples_Manual\n\n# OpenSees -- Open System for Earthquake Engineering Simulation\n# Pacific Earthquake Engineering Research Center\n# http://opensees.berkeley.edu/\n#\n# Basic Elastic Frame\n# ----------------------\n#  2d Elastic Beam Column Elements\n#  Distributed Load & Pushover Analysis\n#\n# Example Objectives\n# -----------------\n#  Simple Introduction to OpenSees\n#\n# Units: kips, in, sec\n# Written: fmk\n# Date: January 2011\n\n#\n# set some parameter\n#\nset PI  [expr 2.0 * asin(1.0)]\nset g   386.4\nset ft  12.0\nset Load1 1185.0;\nset Load2 1185.0;\nset Load3  970.0;\n\n# set floor masses\nset m1  [expr $Load1/(4*$g)]; # 4 nodes per floor\nset m2  [expr $Load2/(4*$g)]\nset m3  [expr $Load3/(4*$g)]\n\n# set floor distributed loads\nset w1  [expr $Load1/(90*$ft)];   # frame 90 ft long\nset w2  [expr $Load2/(90*$ft)]\nset w3  [expr $Load3/(90*$ft)]\n\n# ------------------------------\n# Start of model generation\n# ------------------------------\n\n# Remove existing model\nwipe\n\n# Create ModelBuilder (with two-dimensions and 2 DOF/node)\nmodel BasicBuilder -ndm 2 -ndf 3\n\n# Create nodes\n# ------------\n\n# Create nodes & add to Domain - command: node nodeId xCrd yCrd <-mass $massX $massY $massRz>\n# NOTE: mass in optional\nnode 1     0.0   0.0\nnode 2   360.0   0.0\nnode 3   720.0   0.0\nnode 4  1080.0   0.0\nnode 5    0.0  162.0 -mass $m1 $m1 0.0\nnode 6  360.0  162.0 -mass $m1 $m1 0.0\nnode 7  720.0  162.0 -mass $m1 $m1 0.0\nnode 8 1080.0  162.0 -mass $m1 $m1 0.0\nnode 9     0.0 324.0 -mass $m2 $m2 0.0\nnode 10  360.0 324.0 -mass $m2 $m2 0.0\nnode 11  720.0 324.0 -mass $m2 $m2 0.0\nnode 12 1080.0 324.0 -mass $m2 $m2 0.0\nnode 13    0.0 486.0 -mass $m3 $m3 0.0\nnode 14  360.0 486.0 -mass $m3 $m3 0.0\nnode 15  720.0 486.0 -mass $m3 $m3 0.0\nnode 16 1080.0 486.0 -mass $m3 $m3 0.0\n\n# Set the boundary conditions - command: fix nodeID xResrnt? yRestrnt? rZRestrnt?\nfix 1 1 1 1\nfix 2 1 1 1\nfix 3 1 1 1\nfix 4 1 1 1\n\n# Define geometric transformations for beam-column elements\ngeomTransf Linear 1; # beams\ngeomTransf PDelta 2; # columns\n\n# Define elements\n# Create elastic beam-column - command: element elasticBeamColumn eleID node1 node2 A E Iz geomTransfTag\n\n# Define the Columns\nelement elasticBeamColumn  1  1  5 75.6 29000.0 3400.0 2; # W14X257\nelement elasticBeamColumn  2  5  9 75.6 29000.0 3400.0 2; # W14X257\nelement elasticBeamColumn  3  9 13 75.6 29000.0 3400.0 2; # W14X257\nelement elasticBeamColumn  4  2  6 91.4 29000.0 4330.0 2; # W14X311\nelement elasticBeamColumn  5  6 10 91.4 29000.0 4330.0 2; # W14X311\nelement elasticBeamColumn  6 10 14 91.4 29000.0 4330.0 2; # W14X311\nelement elasticBeamColumn  7  3  7 91.4 29000.0 4330.0 2; # W14X311\nelement elasticBeamColumn  8  7 11 91.4 29000.0 4330.0 2; # W14X311\nelement elasticBeamColumn  9 11 15 91.4 29000.0 4330.0 2; # W14X311\nelement elasticBeamColumn 10  4  8 75.6 29000.0 3400.0 2; # W14X257\nelement elasticBeamColumn 11  8 12 75.6 29000.0 3400.0 2; # W14X257\nelement elasticBeamColumn 12 12 16 75.6 29000.0 3400.0 2; # W14X257\n\n# Define the Beams\nelement elasticBeamColumn 13  5  6 34.7 29000.0 5900.0 1; # W33X118\nelement elasticBeamColumn 14  6  7 34.7 29000.0 5900.0 1; # W33X118\nelement elasticBeamColumn 15  7  8 34.7 29000.0 5900.0 1; # W33X118\nelement elasticBeamColumn 16  9 10 34.2 29000.0 4930.0 1; # W30X116\nelement elasticBeamColumn 17 10 11 34.2 29000.0 4930.0 1; # W30X116\nelement elasticBeamColumn 18 11 12 34.2 29000.0 4930.0 1; # W30X116\nelement elasticBeamColumn 19 13 14 20.1 29000.0 1830.0 1; # W24X68\nelement elasticBeamColumn 20 14 15 20.1 29000.0 1830.0 1; # W24X68\nelement elasticBeamColumn 21 15 16 20.1 29000.0 1830.0 1; # W24X68\n\n\n# Define loads for Gravity Analysis\n# ---------------------------------\n\n#create a Linear TimeSeries (load factor varies linearly with time): command timeSeries Linear $tag\ntimeSeries Linear 1\n\n# Create a Plain load pattern with a linear TimeSeries:\n#  command pattern Plain $tag $timeSeriesTag { $loads }\npattern Plain 1 1 {\n    eleLoad -ele 13 14 15 -type -beamUniform -$w1\n    eleLoad -ele 16 17 18 -type -beamUniform -$w2\n    eleLoad -ele 19 20 21 -type -beamUniform -$w3\n}\n\n# ---------------------------------\n# Create Analysis for Gravity Loads\n# ---------------------------------\n\n# Create the system of equation, a SPD using a band storage scheme\nsystem BandSPD\n\n# Create the DOF numberer, the reverse Cuthill-McKee algorithm\nnumberer RCM\n\n# Create the constraint handler, a Plain handler is used as homo constraints\nconstraints Plain\n\n# Create the integration scheme, the LoadControl scheme using steps of 1.0\nintegrator LoadControl 1.0\n\n# Create the solution algorithm, a Linear algorithm is created\ntest NormDispIncr 1.0e-10 6\nalgorithm Newton\n\n\n\n# create the analysis object\nanalysis Static\n\n\n# ---------------------------------\n# Perform Gravity Analysis\n# ---------------------------------\n\nanalyze 1\n\n# ---------------------------------\n# Check Equilibrium\n# ---------------------------------\n\n# invoke command to determine nodal reactions\nreactions\n\nset node1Rxn [nodeReaction 1]; # nodeReaction command returns nodal reactions for specified node in a list\nset node2Rxn [nodeReaction 2]\nset node3Rxn [nodeReaction 3]\nset node4Rxn [nodeReaction 4]\n\nset inputedFy  [expr -$Load1-$Load2-$Load3]; # loads added negative Fy diren to ele\nset computedFx [expr [lindex $node1Rxn 0]+[lindex $node2Rxn 0]+[lindex $node3Rxn 0]+[lindex $node4Rxn 0]]\nset computedFy [expr [lindex $node1Rxn 1]+[lindex $node2Rxn 1]+[lindex $node3Rxn 1]+[lindex $node4Rxn 1]]\n\nputs "\nEqilibrium Check After Gravity:"\nputs "SumX: Inputed: 0.0 + Computed: $computedFx = [expr 0.0+$computedFx]"\nputs "SumY: Inputed: $inputedFy + Computed: $computedFy = [expr $inputedFy+$computedFy]"\n\n# ---------------------------------\n# Lateral Load\n# ---------------------------------\n\n# set gravity loads constant and time in domain to e 0.0\nloadConst -time 0.0\n\ntimeSeries Linear 2\npattern Plain 2 2 {\n    load 13 220.0 0.0 0.0\n    load  9 180.0 0.0 0.0\n    load  5  90.0 0.0 0.0\n}\n\n# ---------------------------------\n# Create Recorder\n# ---------------------------------\n\nrecorder Element -file EleForces.out -ele 1 4 7 10 forces\n\n# ---------------------------------\n# Perform Lateral Analysis\n# ---------------------------------\n\nanalyze 1\n\n# ---------------------------------\n# Check Equilibrium\n# ---------------------------------\n\nreactions\n\nset node1Rxn [nodeReaction 1]; # nodeReaction command returns nodal reactions for specified node in a list\nset node2Rxn [nodeReaction 2]\nset node3Rxn [nodeReaction 3]\nset node4Rxn [nodeReaction 4]\n\nset inputedFx  [expr 220.0+180.0+90.0]\nset computedFx [expr [lindex $node1Rxn 0]+[lindex $node2Rxn 0]+[lindex $node3Rxn 0]+[lindex $node4Rxn 0]]\nset computedFy [expr [lindex $node1Rxn 1]+[lindex $node2Rxn 1]+[lindex $node3Rxn 1]+[lindex $node4Rxn 1]]\n\nputs "\nEqilibrium Check After Lateral Loads:"\nputs "SumX: Inputed: $inputedFx + Computed: $computedFx = [expr $inputedFx+$computedFx]"\nputs "SumY: Inputed: $inputedFy + Computed: $computedFy = [expr $inputedFy+$computedFy]"\n\n# print ele information for columns at base\nprint ele 1 4 7 10\n\n# ---------------------------------\n# Check Eigenvalues\n# ---------------------------------\n\nset eigenValues [eigen 5]\n\nputs "\nEigenvalues:"\nset eigenValue [lindex $eigenValues 0]\nputs "T[expr 0+1] = [expr 2*$PI/sqrt($eigenValue)]"\nset eigenValue [lindex $eigenValues 1]\nputs "T[expr 1+1] = [expr 2*$PI/sqrt($eigenValue)]"\nset eigenValue [lindex $eigenValues 2]\nputs "T[expr 2+1] = [expr 2*$PI/sqrt($eigenValue)]"\nset eigenValue [lindex $eigenValues 3]\nputs "T[expr 3+1] = [expr 2*$PI/sqrt($eigenValue)]"\nset eigenValue [lindex $eigenValues 4]\nputs "T[expr 4+1] = [expr 2*$PI/sqrt($eigenValue)]"\n\nrecorder Node -file eigenvector.out -nodeRange 5 16 -dof 1 2 3 eigen 0\nrecord\n\nexit'
  'Example-EigenAnal_twostoreyframe...':
    'prefix': 'Example - EigenAnal_twostoreyframe'
    'body': '# Full documentation at:\n# http://opensees.berkeley.edu/wiki/index.php/Basic_Examples_Manual\n\n# Eigen analysis of a two-storey one-bay frame; Example 10.5 from "Dynamics of Structures" book by Anil Chopra\n\n# units: kips, in, sec\n\n#       Vesna Terzic, 2010\n\n#delete all previosly constructed objects\nwipe;\n\n#set input variables\n#--------------------\n\n#mass\nset m  [expr 100.0/386.0]\n\n#number of modes\nset numModes 2\n\n#material\nset A 63.41\nset I 320.0\nset E 29000.0\n\n#geometry\nset L 240.\nset h  120.\n\n# create data directory\nfile mkdir modes;\n\n# define the model\n#---------------------------------\n#model builder\nmodel BasicBuilder -ndm 2 -ndf 3\n\n# nodal coordinates:\nnode 1   0.  0. ;\nnode 2   $L  0. ;\nnode 3   0.  $h ;\nnode 4   $L  $h ;\nnode 5   0.  [expr 2*$h];\nnode 6   $L  [expr 2*$h];\n\n# Single point constraints -- Boundary Conditions\nfix 1 1 1 1;\nfix 2 1 1 1;\n\n# assign mass\nmass 3 $m 0. 0. ;\nmass 4 $m 0. 0. ;\nmass 5 [expr $m/2.] 0. 0. ;\nmass 6 [expr $m/2.] 0. 0. ;\n\n# define geometric transformation:\nset TransfTag 1;\ngeomTransf Linear $TransfTag ;\n\n# define elements:\n# columns\nelement elasticBeamColumn 1 1 3 $A $E [expr 2.*$I] $TransfTag;\nelement elasticBeamColumn 2 3 5 $A $E $I           $TransfTag;\nelement elasticBeamColumn 3 2 4 $A $E [expr 2.*$I] $TransfTag;\nelement elasticBeamColumn 4 4 6 $A $E $I           $TransfTag;\n# beams\nelement elasticBeamColumn 5 3 4 $A $E [expr 2.*$I] $TransfTag;\nelement elasticBeamColumn 6 5 6 $A $E $I           $TransfTag;\n\n# record eigenvectors\n#----------------------\nfor { set k 1 } { $k <= $numModes } { incr k } {\n    recorder Node -file [format "modes/mode%i.out" $k] -nodeRange 1 6 -dof 1 2 3  "eigen $k"\n}\n\n# perform eigen analysis\n#-----------------------------\nset lambda [eigen  $numModes];\n\n# calculate frequencies and periods of the structure\n#---------------------------------------------------\nset omega {}\nset f {}\nset T {}\nset pi 3.141593\n\nforeach lam $lambda {\n	lappend omega [expr sqrt($lam)]\n	lappend f [expr sqrt($lam)/(2*$pi)]\n	lappend T [expr (2*$pi)/sqrt($lam)]\n}\n\nputs "periods are $T"\n\n# write the output file cosisting of periods\n#--------------------------------------------\nset period "modes/Periods.txt"\nset Periods [open $period "w"]\nforeach t $T {\n	puts $Periods " $t"\n}\nclose $Periods\n\n# record the eigenvectors\n#------------------------\nrecord\n\n# create display  for mode shapes\n#---------------------------------\n#                 $windowTitle $xLoc $yLoc $xPixels $yPixels\nrecorder display "Mode Shape 1"  10    10     500      500     -wipe\nprp $h $h 1;                                         # projection reference point (prp); defines the center of projection (viewer eye)\nvup  0  1 0;                                         # view-up vector (vup)\nvpn  0  0 1;                                         # view-plane normal (vpn)\nviewWindow -200 200 -200 200;                        # coordiantes of the window relative to prp\ndisplay -1 5 20;                                     # the 1st arg. is the tag for display mode (ex. -1 is for the first mode shape)\n                                                     # the 2nd arg. is magnification factor for nodes, the 3rd arg. is magnif. factor of deformed shape\nrecorder display "Mode Shape 2" 10 510 500 500 -wipe\nprp $h $h 1;\nvup  0  1 0;\nvpn  0  0 1;\nviewWindow -200 200 -200 200\ndisplay -2 5 20\n\n# get values of eigenvectors for translational DOFs\n#---------------------------------------------------\nset f11 [nodeEigenvector 3 1 1]\nset f21 [nodeEigenvector 5 1 1]\nset f12 [nodeEigenvector 3 2 1]\nset f22 [nodeEigenvector 5 2 1]\nputs "eigenvector 1: [list [expr {$f11/$f21}] [expr {$f21/$f21}] ]"\nputs "eigenvector 2: [list [expr {$f12/$f22}] [expr {$f22/$f22}] ]"'
# Templates
  'Template...':
    'prefix': 'Template of OpenSees model'
    'body': '# ============================================================================ #\n#                                 Model Title                                  #\n# \n# Description: Model description\n# Units: kg, m, s\n#\n# Written: Star Lord\n# Date: dd / mm / 20XX\n# ============================================================================ #\n\n\n# Model definition\n# ---------------------------------------------------------------------------- #\n\nwipe\nmodel BasicBuilder -ndm $ndm <-ndf $ndf>\n\n# Create nodes\nnode $nodeTag (ndm $coords)\nnode $nodeTag (ndm $coords)\n# continue adding all nodes...\n\n# Set boundary conditions\nfix $nodeTag (ndf $constrValues)\n# continue adding all boundary conditions...\n\n# Define materials\nuniaxialMaterial Elastic $matTag $E <$eta> <$Eneg>\nuniaxialMaterial Steel01 $matTag $Fy $E0 $b <$a1 $a2 $a3 $a4>\n# continue defining all materials...\n\n# Create elements\nelement truss $eleTag $iNode $jNode $A $matTag <-rho $rho> <-cMass $cFlag> <-doRayleigh $rFlag>\n# continue creating all elements...\n\n# Define loads\ntimeSeries Linear $tag <-factor $cFactor>\npattern Plain $patternTag $tsTag <-fact $cFactor> {\n	load...\n	eleLoad...\n	sp...\n	...\n}\n\n\n# Analysis generation\n# ---------------------------------------------------------------------------- #\n\nconstraints ...\nnumberer ...\nsystem ...\ntest ...\nalgorithm ...\nintegrator ...\nanalysis ...\n\n\n# Analysis generation\n# ---------------------------------------------------------------------------- #\n\n# Node recorders\nrecorder Node <-file $fileName> <-xml $fileName> <-binary $fileName> <-tcp $inetAddress $port> <-precision $nSD> <-timeSeries $tsTag> <-time> <-dT $deltaT> <-closeOnWrite> <-node $node1 $node2 ...> <-nodeRange $startNode $endNode> <-region $regionTag> -dof ($dof1 $dof2 ...) $respType\n# continue adding required node recorders...\n\n# Element recorders\nrecorder Element <-file $fileName> <-xml $fileName> <-binary $fileName> <-precision $nSD> <-time> <-closeOnWrite> <-dT $deltaT> <-ele ($ele1 $ele2 ...)> <-eleRange $startEle $endEle> <-region $regTag> $arg1 $arg2 ...\n# continue adding required element recorders...\n\n# Other recoders\n# add any other recorders...\n\n\n# Perform analysis\n# ---------------------------------------------------------------------------- #\n\nanalyze $numIncr <$dt> <$dtMin $dtMax $Jd>\n\n# Print some things\nputs "node A displacement: [nodeDisp A]"\nprint node B\nprint ele C\n# continue adding printed information...'
